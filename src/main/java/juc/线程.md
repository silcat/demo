#线程
##线程状态
````
1.新建状态(New)：
当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行。

2.就绪状态(Runnable)
- 一个新创建的线程调用线程的start()方法,当start()方法返回后，线程就处于就绪状态。
- 处于就绪状态的线程并不一定立即运行run()方法,线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。

3.运行状态(Running)
当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.

4. 阻塞状态(Blocked)
0>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。
1>线程通过调用sleep方法进入睡眠状态；
2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
3>线程试图得到一个锁，而该锁正被其他线程持有；
4>线程在等待某个触发条件；         

5. 死亡状态(Dead)
有两个原因会导致线程死亡：
1) run方法正常退出而自然死亡，
2) 一个未捕获的异常终止了run方法而使线程猝死。
3)为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false.
````
##异同
|  表头  | 是否释放锁 | 线程状态 |执行后续代码 | 异常处理  |继续方式|实现方式|
|  ----  | ----  | ----  | ----  | ----  | ----  |  ----  |  
| Object.wait()|释放锁 | 阻塞| 可能执行后续代码|中断异常 |Object.notify|native方法|
| Condition.wait()|释放锁 | 阻塞| 可能执行后续代码|中断异常 |Object.notify|LockPark.park()|
| LockPark.park()| 不释放 | 阻塞|一定执行后续代码 | 不抛异常| unpark()|unsafe.park|
| Thread.sleep()| 不释放 | 阻塞|一定执行后续代码 | 中断异常| 阻塞时间到了|native方法|
| Thread.yield()| 不释放 | 可运行|一定执行后续代码 | 不抛异常| 等待调度|native方法|
| childThread.join()| 不释放 | 阻塞|一定执行后续代码 | 中断异常| 子线程运行完毕|native方法|
| Thread.interrupt()|- | 不影响线程状态|设置线程中断不影响线程的继续执行| | 调用了wait、join、sleep,抛出中断异常 |native方法|
