##参考文档
* https://notes.diguage.com/mysql/#schema-speed-up-alter

## 数据库组件结构
````
1.连接池组建
2. 管理服务和工具组建
3. SQL接口组件（SQL Interface）
4. 查询分析器（Parser）
5. 优化器组件（OpTImizer）
6. 缓冲组件（Cache & Buffer）
7. 插件式存储引擎（Pluggable Storage Engines）
8. 物理文件 （File Sysgtem & Logs）
````
````
1.数据库是文件集合，数据库实例是程序，两者通过插件式的存储引擎交互，而对开发人员通过数据库实例来操作数据库
````
## 数据库需要解决的问题
* 数据库的事务隔离是为解决事务不隔离而产生的脏读、幻读、不可重复读等问题。
* 而数据库事务的隔离性是通过锁机制和mvcc来实现的
    
##数据库事务
* 事务隔离级别
  * Read Uncommitted(未提交读)
    * 事务可以读取其他事务未提交的数据
    * 出现脏读(Dirty Read)
  * Read Committed(提交读)
    * 一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。
    * 解决脏读
  * Repeatable Read(可重复读)
    * 在同一个事务内的查询都是事务开始时刻一致的
    * 解决不可重复读，仍存在幻读
    * 幻读与不可用重复读的区别：幻读是因为insert导致的，不可以重复读是因为更新导致;
    * mysql数据库可重复读隔离级别解决了幻读问题。
  * Serializable(可串行化)
    * Serializable 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读问题。简单来说，Serializable 会在读取的每一行数据上都加锁，所以导致大量的超时和锁争用的问题。实际中，极少使用。
  * Repeatable Read(可重复读) 是 MySQL 默认事务隔离级别。

##MVVC

* 什么是MVVC
    ````
    MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。
    MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。
    这种乐观锁只在事务级别未提交锁和已提交锁时才会生效。
    MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。
    在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。具体见下面介绍。
    ````
* MVCC的实现机制
  * InnoDB在每行数据都增加两个隐藏字段，一个记录创建的版本号，一个记录删除的版本号;
  * 在每开启一个事务时会生成一个事务的版本号和该数据行的快照(临时表)。  
  * 可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。 
  * 事务提交成功，将新的版本号更新到此数据行中。
# mysql的锁机制

# mysql实现可重复读隔离级别机制  
* 通过MVVC机制，mysql了实现可重复读，以及在可重复读隔离级别下解决了幻读。