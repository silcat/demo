#元数据区
##概念
- 元数据区也是一块线程共享的内存区域，
- 保存被虚拟机加载的类信息、常量、静态变量以及即时编译器编译后的代码等数据
- 它被安置在一块堆外内存，大小由-XX:MaxMetaspaceSize指定。

````
1. 堆内内存:JVM所分配管理的内存（-Xms所设定内存）
2. 堆外外内存：非JVM管理的内存，NIO-DirectByteBuffer（https://www.jianshu.com/p/007052ee3773）
 - -XX:MaxDirectMemorySize来指定最大的堆外内存。
 - -Dsun.nio.MaxDirectMemorySize指定了这个属性，且它不等于-1。
 - 默认directMemory = Runtime.getRuntime().maxMemory()，这是一个native方法
````
##常量（JDK1.7以及之后的版本）
* 常量指一切不变的东西，不要简单理解为final修饰的变量
## 类文件常量池
* 此时没有加载进内存，存放于文件中
* 用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
* 字面量是指面量和声明为 final 的（基本数据类型）常量值,
* 符号引用，就是字面量的引用，包括类和接口的全限定名(包括包路径的完整名)、字段的名称和描述符、方法的名称和描述符
````
  tring str1 = "aaa"; "aaa"及字面量 ，str1为符号引用
````
## 运行时常量池
* 类文件常量池会在类加载后加入方法区/元数据区中的运行时常量池【此时存在在内存中】
* 运行时常量池是存在方法区/元数据区。
* class文件中类文件常量池多个相同的字符串在运行时常量池只会存在一份
* 程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。
* 类在解析之后将符号引用替换成直接引用，与全局常量池中的引用值保持一致。
## 字符串常量池
* 字符串常量池存在于堆中，运行时常量池并没有包含字符串常量池

## intern()
* JDK7后，字符串常量池中存储的是对象的引用，而对象本身存储于堆中
    * 判断字符串常量是否在字符串常量池中
        * 存在直接返回此字符串对象的引用
        * 不存在且堆中已有该字符串对象，将该字符串对象的引用添加到字符串常量池
        * 不存在且堆中没有此字符串对象，则先在堆中创建字符串对象，再返回其引用。

````
    String str1 = new String("aa");//创建了两个“aa”对象，一个存在字符串常量池中，一个存在堆中。
    str1.intern();//由于字符串常量池中已经存在“aa”对象，故s1指向字符串常量池中的对象。
    String str2 = "aa";//字符串常量池中已经存在“aa”对象，所以也直接返回字符串常量池对象地址
    System.out.println(str1 == str2); 
    解析：str1指堆aa对象，str2指向常量池"aa"对象,故false；
    ====================================================================================
    //创建5个对象，堆"aa","bb"，"aabb"对象，常量池"aa","bb"对象，"aabb"对象引用赋予str3
    String str3 = new String("aa") + new String("bb");
    //"aabb"不在常量池中且堆中"aabb"对象，将堆"aabb"对象引用添加到常量池
    t3.intern();
    String str4 = "aabb";
    System.out.println(str3 == str4); 
　　解析：在jdk1.7中为true；

````
##类加载机制：加载 准备 验证 解析 初始化 使用 卸载


