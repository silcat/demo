##为什么使用缓存
* 高性能:非实时变化的数据-查询mysql耗时需要300ms,存到缓存redis，每次查询仅仅1ms,性能瞬间提升百倍。    
* 高并发:mysql 单机支撑到2K QPS就容易报警了，但是使用缓存的话，单机支撑的并发量轻松1s几万~十几万。原因是缓存位于内存，内存对高并发的良好支持。
* 现有硬件系统难以处理的高性能高并发都可以用缓存来优化
##缓存的使用方式
* 本地缓存：
    * 局部变量map结构缓存部分业务数据。缺点仅限于类的自身作用域内，类间无法共享缓存
    * 静态变量map一次获取缓存内存中，静态变量实现类间可共享，进程内可共享，缓存的实时性稍差
        * 结合ZooKeeper的自动发现机制，实时变更本地静态变量缓存
        * https://www.jianshu.com/p/40cdd4bfe183
    * Ehcache纯Java的进程内缓存框架
        * https://www.cnblogs.com/liululee/p/13354481.html
    * spring注解
* 分布式缓存 
    * memcached缓存
        * MemCache是一个自由、源码开放、高性能、分布式的分布式内存对象缓存系统；
        * MemCache虽然被称为"分布式缓存"，但是MemCache本身完全不具备分布式的功能，MemCache集群之间不会相互通信，所谓的"分布式"，完全依赖于客户端程序的实现
        * MemCache集群的方式也是从分区容错性的方面考虑的，假如Node1宕机了，此时由于集群中其他节点数据还存在。
    * redis缓存 
* Spring注解缓存
    * 参考文档
        * https://developer.ibm.com/zh/articles/os-cn-spring-cache/
        * https://www.xuebuyuan.com/2174369.html
     
##缓存应该注意的问题
* 缓存雪崩
    * 于系统 A，假设本来缓存在高峰期可以扛住4000 QPS，单机数据库最大支持每秒2000QPS，但是缓存机器意外发生了全盘宕机或同时失效，数据库必然扛不住，然后就挂了。此时，如果没用什么特别的方案来处理这个故障，重启数据库，但是数据库立马又被新的流量给打死了。
    * 处理方式
        * 批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，避免缓存同时失效
        * 如果redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题 
        * 设置热点数据永远不过期，有更新操作就更新缓存就好了
        * 除了redis，本地用 ehcache 缓存 + hystrix 限流&降级 ，先查ehcache 缓存缓存不存在再查数据库
        * redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据
* 缓存穿透
    * 对于系统A，假如不做参数校验，每次请求不存在数据库中也不存在缓存中，每次都这样，并发高点就容易崩掉了 
    * 处理方式
        * 通过bitMap进行参数校验，不存在数据库的请求直接拦截
        * 数据库不存在缓存中设置一个空值，设置过期时间
* 缓存击穿
    * 对于系统A，假如每秒5000个请求中4000个请求都是请求同一个key，则当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库            
    * 处理方式
        * 设置热点数据永远不过期
        * 读取数据库加上分布式锁
* 缓存与数据库双写的一致性 
    * 先更新数据库，再更新缓存（不可取）
     ````
     原因一（线程安全角度） 同时有请求A和请求B进行更新操作，那么会出现
     
     （1）线程A更新了数据库
     （2）线程B更新了数据库
     （3）线程B更新了缓存
     （4）线程A更新了缓存
     这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。
     原因二（业务场景角度） 有如下两点：
     
     （1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。
     （2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。
     ````
    * 先删缓存，再更新数据库（不可取）
    ````
    该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:
    （1）请求A进行写操作，删除缓存
    （2）请求B查询发现缓存不存在
    （3）请求B去数据库查询得到旧值
    （4）请求B将旧值写入缓存
    （5）请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。
    那么，如何解决呢？采用延时双删策略 伪代码如下
    ````
    * 非读写分离框架: 先删缓存，再更新数据库,休眠1秒后删除缓存，如此可以将脏数据删除（可取）
    ````
    如果你用了mysql的读写分离架构？
    造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。   
    （1）请求A进行写操作，删除缓存
    （2）请求A将数据写入数据库了，
    （3）请求B查询缓存发现，缓存没有值
    （4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
    （5）请求B将旧值写入缓存
    （6）数据库完成主从同步，从库变为新值 上述情形，就是数据不一致的原因。。
    采用这种同步淘汰策略，吞吐量降低怎么办？
    ````
    * 读写分离：先删缓存，再更新数据库,休眠 1秒+主从同步时间 后删除缓存，但依旧第二次存在删除缓存导致的数据不一致
    * 先更新数据库，异步延时删除缓存，若缓存删除失败则重试
##实例解析


